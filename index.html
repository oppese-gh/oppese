<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>いぼ次元ラッシュ v0.10</title>
  <style>
    body {
      margin: 0;
      background: #f7e4c9;
      font-family: "Yu Gothic", sans-serif;
      user-select: none;
    }
    canvas {
      display: block;
      margin: 20px auto;
      background: #fbe9d0;
      border: 4px solid #c96;
      border-radius: 8px;
    }
    #info {
      text-align: center;
      font-size: 14px;
      color: #444;
    }
  </style>
</head>
<body>
<canvas id="game" width="800" height="480"></canvas>
<div id="info">
  いぼ次元ラッシュ v0.10　
  ← →：移動　／　Space：ジャンプ　／　I：いぼミサイル　／　Enter：スタート／次へ
</div>

<script>
// ==== IboJigen Rush v0.10 =======================================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false; // ドット感維持

// 地面を画面のかなり下に
const GROUND_Y = 400;

// ゲーム状態
const STATE_TITLE      = 0;
const STATE_PLAYING    = 1;
const STATE_GAMEOVER   = 2;
const STATE_STAGE_CLEAR = 3;

// ジャンプ力（マイナスが上向き）
const PLAYER_JUMP_POWER = -16; // イボジッチ
const ENEMY_JUMP_POWER  = -13; // キレジッチ

// ビームの基準値
const BEAM_BASE_SPEED    = 9;     // px/フレーム
const BEAM_BASE_LIFE     = 1500;  // ms
const BEAM_BASE_COOLDOWN = 900;   // ms

// ===== スプライト（256x256想定） =====
const iboImg  = new Image();
const kireImg = new Image();
iboImg.src  = "ibojitch.png";
kireImg.src = "kirejitch.png";

let assetsLoaded = 0;
[iboImg, kireImg].forEach(img => {
  img.onload = () => {
    assetsLoaded++;
    if (assetsLoaded === 2) startGame();
  };
});

let state = STATE_TITLE;
let keys = {};
let lastTime = 0;

// ステージ 1〜3
let stage = 1;
const MAX_STAGE = 3;
let stageClearText = "";

class Fighter {
  constructor(x, colorBase, isEnemy=false) {
    this.x = x;
    this.y = GROUND_Y;
    this.w = 70;   // 当たり判定用
    this.h = 150;
    this.speed = 4;
    this.colorBase = colorBase;
    this.isEnemy = isEnemy;
    this.hp = 6;
    this.maxHp = 6;
    this.vy = 0;
    this.onGround = true;
    this.facing = isEnemy ? -1 : 1;
    this.missileCooldown = 0;
    this.beamCooldown = 0;
    this.aiMove = 0;
    this.aiBeam = false;
  }
  rect() {
    return {
      x: this.x - this.w / 2,
      y: this.y - this.h,
      w: this.w,
      h: this.h
    };
  }
}

const player = new Fighter(180, "#b673ff", false);
const enemy  = new Fighter(620, "#f5d3a5", true);

let missiles = [];
let beams    = [];
let resultText = "";

// ===== 入力 =====
document.addEventListener("keydown", e => {
  keys[e.key] = true;

  if (["ArrowLeft","ArrowRight"," ","Spacebar","i","I"].includes(e.key)) {
    e.preventDefault();
  }

  if (state === STATE_TITLE && e.key === "Enter") {
    stage = 1;
    resetGame();
    state = STATE_PLAYING;
  }

  if (state === STATE_GAMEOVER && e.key === "Enter") {
    // タイトルに戻す
    stage = 1;
    state = STATE_TITLE;
  }

  if (state === STATE_STAGE_CLEAR && e.key === "Enter") {
    // 次ステージへ
    stage++;
    if (stage > MAX_STAGE) stage = MAX_STAGE;
    resetGame();
    state = STATE_PLAYING;
  }

  if (state === STATE_PLAYING) {
    if (e.key === " " || e.key === "Spacebar") {
      if (player.onGround) {
        player.vy = PLAYER_JUMP_POWER;
        player.onGround = false;
      }
    }
    if ((e.key === "i" || e.key === "I") && player.missileCooldown === 0) {
      shootMissile();
    }
  }
});

document.addEventListener("keyup", e => {
  keys[e.key] = false;
});

// ===== Utility =====
function clamp(v, min, max) {
  return Math.max(min, Math.min(max, v));
}
function rectIntersect(a, b) {
  return (
    a.x < b.x + b.w &&
    a.x + a.w > b.x &&
    a.y < b.y + b.h &&
    a.y + a.h > b.y
  );
}

function resetGame() {
  // ステージ開始時に両者全回復・位置リセット
  player.x = 180;
  player.y = GROUND_Y;
  player.vy = 0;
  player.onGround = true;
  player.hp = player.maxHp;
  player.missileCooldown = 0;

  enemy.x = 620;
  enemy.y = GROUND_Y;
  enemy.vy = 0;
  enemy.onGround = true;
  enemy.hp = enemy.maxHp;
  enemy.beamCooldown = 0;

  missiles = [];
  beams = [];
  resultText = "";
  stageClearText = "";
}

function update(dt) {
  if (state !== STATE_PLAYING) return;

  player.missileCooldown = Math.max(0, player.missileCooldown - dt);
  enemy.beamCooldown    = Math.max(0, enemy.beamCooldown - dt);

  updatePlayer();
  updateEnemy(dt);
  updateMissiles();
  updateBeams(dt);

  player.facing = (enemy.x >= player.x) ? 1 : -1;
  enemy.facing  = (player.x >= enemy.x) ? -1 : 1;

  if (player.hp <= 0) {
    state = STATE_GAMEOVER;
    resultText = "イボジッチ敗北…";
  } else if (enemy.hp <= 0) {
    if (stage < MAX_STAGE) {
      // ステージクリア → 次ステージへ
      state = STATE_STAGE_CLEAR;
      stageClearText = getStageClearMessage(stage);
    } else {
      // 最終ステージ撃破 → 完全勝利
      state = STATE_GAMEOVER;
      resultText = "勝利！いぼ次元制圧！";
    }
  }
}

function getStageClearMessage(stageNum) {
  if (stageNum === 1) {
    return "キレジッチ「今のは俺の本気ではない」";
  } else if (stageNum === 2) {
    return "キレジッチ「！…まだだ、まだこれからだ」";
  }
  return "";
}

function applyGravity(f) {
  f.y += f.vy;
  if (!f.onGround) {
    f.vy += 0.6; // 重力
  }
  if (f.y >= GROUND_Y) {
    f.y = GROUND_Y;
    f.vy = 0;
    f.onGround = true;
  }
}

function updatePlayer() {
  if (keys["ArrowLeft"])  player.x -= player.speed;
  if (keys["ArrowRight"]) player.x += player.speed;
  player.x = clamp(player.x, 70, canvas.width - 70);
  applyGravity(player);
}

let enemyThinkTime = 0;
function updateEnemy(dt) {
  enemyThinkTime -= dt;
  if (enemyThinkTime <= 0) {
    enemyThinkTime = 400;
    enemyAiDecision();
  }

  enemy.x += enemy.aiMove * enemy.speed * 0.6;
  enemy.x = clamp(enemy.x, 70, canvas.width - 70);

  maybeEnemyDodgeJump(); // 回避ジャンプ

  applyGravity(enemy);

  if (enemy.aiBeam && enemy.beamCooldown === 0) {
    shootBeam();
  }
}

// ===== キレジッチAI =====
function enemyAiDecision() {
  const dist = player.x - enemy.x;
  const absDist = Math.abs(dist);

  enemy.aiMove = 0;
  enemy.aiBeam = false;

  if (absDist > 260) {
    enemy.aiMove = dist > 0 ? 1 : -1;
  } else if (absDist > 160) {
    enemy.aiBeam = Math.random() < 0.7;
    enemy.aiMove = dist > 0 ? 0.2 : -0.2;
  } else {
    enemy.aiMove = dist > 0 ? -0.6 : 0.6;
    enemy.aiBeam = Math.random() < 0.5;
  }
}

// ★ キレジッチ回避ジャンプ
function maybeEnemyDodgeJump() {
  if (!enemy.onGround) return;
  if (missiles.length === 0) return;

  let closest = null;
  let minDist = Infinity;
  missiles.forEach(m => {
    const d = Math.abs(m.x - enemy.x);
    if (d < minDist) {
      minDist = d;
      closest = m;
    }
  });
  if (!closest) return;

  const towardEnemy =
    (closest.vx > 0 && closest.x < enemy.x) ||
    (closest.vx < 0 && closest.x > enemy.x);

  if (!towardEnemy) return;

  const horizontalOk = Math.abs(closest.x - enemy.x) < 240;
  const dy = Math.abs(closest.y - (enemy.y - enemy.h * 0.5));
  const verticalOk = dy < 90;

  if (horizontalOk && verticalOk) {
    if (Math.random() < 0.6) {
      enemy.vy = ENEMY_JUMP_POWER;
      enemy.onGround = false;
    }
  }
}

// ===== イボミサイル =====
function shootMissile() {
  player.missileCooldown = 350;
  const dir = player.facing;
  const r = player.rect();
  const startX = player.x + dir * (player.w/2 + 8);
  const startY = r.y + r.h * 0.45;
  missiles.push({
    x: startX,
    y: startY,
    r: 10,
    vx: dir * 7.5,
    alive: true
  });
}

function updateMissiles() {
  missiles.forEach(m => {
    m.x += m.vx;
    if (m.x < -50 || m.x > canvas.width + 50) m.alive = false;

    const mr = { x: m.x - m.r, y: m.y - m.r, w: m.r*2, h: m.r*2 };
    if (rectIntersect(mr, enemy.rect())) {
      enemy.hp -= 1;
      m.alive = false;
    }
  });
  missiles = missiles.filter(m => m.alive);
}

// ===== ビーム（ステージ性能反映） =====
function getBeamParamsForStage() {
  let speed     = BEAM_BASE_SPEED;
  let life      = BEAM_BASE_LIFE;
  let cooldown  = BEAM_BASE_COOLDOWN;
  let bidirect  = false;

  if (stage >= 2) {
    life *= 1.2;       // 射程1.2倍
    bidirect = true;   // 左右どちらにも撃てる
  }
  if (stage >= 3) {
    cooldown *= 0.8;   // 発射間隔 0.8倍（速くなる）
  }
  return { speed, life, cooldown, bidirect };
}

function shootBeam() {
  const params = getBeamParamsForStage();
  enemy.beamCooldown = params.cooldown;

  const r = enemy.rect();
  const bandageX = enemy.x;
  const bandageY = r.y + r.h * 0.02;

  const startX = bandageX - 4;
  const startY = bandageY - 4;

  // 向き決定：Stage1 は左固定、Stage2以降はプレイヤー側へ
  let dir = -1;
  if (params.bidirect) {
    dir = (player.x >= enemy.x) ? 1 : -1;
  }

  beams.push({
    x: startX,
    y: startY,
    w: 36,
    h: 8,
    vx: dir * params.speed,
    life: params.life,
    alive: true
  });
}

function updateBeams(dt) {
  beams.forEach(b => {
    b.x += b.vx;
    b.life -= dt;
    if (b.life <= 0 || b.x + b.w < 0 || b.x > canvas.width + 50) {
      b.alive = false;
    }

    if (rectIntersect(b, player.rect())) {
      player.hp -= 1;
      b.alive = false;
    }
  });
  beams = beams.filter(b => b.alive);
}

// ===== 描画 =====
function drawBackground() {
  ctx.fillStyle = "#fbe9d0";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "#e0b47a";
  ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);

  ctx.fillStyle = "#d7a96b";
  ctx.fillRect(0, GROUND_Y - 22, canvas.width, 22);

  ctx.fillStyle = "#9ccc65";
  for (let i = 0; i < 6; i++) {
    const x = 60 + i * 130;
    ctx.beginPath();
    ctx.arc(x, GROUND_Y - 60, 30, 0, Math.PI * 2);
    ctx.fill();
  }

  const baseX = 600;
  const baseY = GROUND_Y - 22;
  ctx.strokeStyle = "#c48a5a";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(baseX - 40, baseY);
  ctx.lineTo(baseX, baseY - 150);
  ctx.lineTo(baseX + 40, baseY);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(baseX - 30, baseY - 50);
  ctx.lineTo(baseX + 30, baseY - 50);
  ctx.moveTo(baseX - 20, baseY - 90);
  ctx.lineTo(baseX + 20, baseY - 90);
  ctx.stroke();
}

function drawShadow(f) {
  ctx.fillStyle = "rgba(0,0,0,0.15)";
  const scale = f.onGround ? 1 : 0.8;
  ctx.beginPath();
  ctx.ellipse(f.x, GROUND_Y + 4, 28 * scale, 10 * scale, 0, 0, Math.PI * 2);
  ctx.fill();
}

function drawSpriteCharacter(f, img) {
  const srcW = img.width;
  const srcH = img.height;

  const drawH = 210;
  const drawW = drawH * (srcW / srcH);
  const dx = f.x - drawW / 2;
  const dy = f.y - drawH;  // 足元が f.y に来る

  drawShadow(f);
  ctx.save();
  if (!f.isEnemy && f.facing === -1) {
    ctx.translate(f.x, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(img, -drawW / 2, dy, drawW, drawH);
  } else {
    ctx.drawImage(img, dx, dy, drawW, drawH);
  }
  ctx.restore();
}

function drawMissiles() {
  missiles.forEach(m => {
    ctx.beginPath();
    ctx.fillStyle = "#7e3cff";
    ctx.arc(m.x, m.y, m.r, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = "#4b1d99";
    for (let i = 0; i < 6; i++) {
      const a = (Math.PI * 2 / 6) * i;
      const x1 = m.x + Math.cos(a)*m.r;
      const y1 = m.y + Math.sin(a)*m.r;
      const x2 = m.x + Math.cos(a)*(m.r+6);
      const y2 = m.y + Math.sin(a)*(m.r+6);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
  });
}

function drawBeams() {
  beams.forEach(b => {
    const grad = ctx.createLinearGradient(b.x, b.y, b.x + b.w, b.y);
    grad.addColorStop(0,   "rgba(255,230,230,0.15)");
    grad.addColorStop(0.3, "rgba(255,120,120,0.9)");
    grad.addColorStop(1,   "rgba(120,0,0,0.9)");
    ctx.fillStyle = grad;
    ctx.fillRect(b.x, b.y, b.w, b.h);

    ctx.fillStyle = "rgba(255,0,0,0.25)";
    ctx.fillRect(b.x, b.y - 4, b.w, b.h + 8);
  });
}

function drawHpBar(f, x, y) {
  const w = 180;
  const h = 16;
  ctx.fillStyle = "#ddd";
  ctx.fillRect(x, y, w, h);
  const ratio = f.hp / f.maxHp;
  ctx.fillStyle = f === player ? "#a040ff" : "#ff5f5f";
  ctx.fillRect(x, y, w * ratio, h);
  ctx.strokeStyle = "#333";
  ctx.strokeRect(x, y, w, h);
}

function drawStageLabel() {
  ctx.fillStyle = "#333";
  ctx.font = "18px 'Yu Gothic'";
  ctx.fillText("STAGE " + stage, canvas.width/2 - 40, 26);
}

function drawTitle() {
  drawBackground();

  ctx.fillStyle = "#d84315";
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 6;
  ctx.font = "bold 64px 'Yu Gothic'";
  const title = "いぼ次元ラッシュ";
  const tw = ctx.measureText(title).width;
  ctx.strokeText(title, (canvas.width - tw)/2, 140);
  ctx.fillText(title, (canvas.width - tw)/2, 140);

  ctx.font = "24px 'Yu Gothic'";
  ctx.fillStyle = "#444";
  ctx.fillText("Enterキーでスタート", canvas.width/2 - 110, 200);

  ctx.font = "16px 'Yu Gothic'";
  ctx.fillText("← →：移動　Space：ジャンプ　I：いぼミサイル", canvas.width/2 - 170, 230);

  drawStageLabel();
  drawSpriteCharacter(player, iboImg);
  drawSpriteCharacter(enemy,  kireImg);
}

function drawGame() {
  drawBackground();
  drawSpriteCharacter(player, iboImg);
  drawSpriteCharacter(enemy,  kireImg);

  drawMissiles();
  drawBeams();

  drawHpBar(player, 40, 40);
  drawHpBar(enemy, canvas.width - 220, 40);
  drawStageLabel();

  ctx.fillStyle = "#444";
  ctx.font = "16px 'Yu Gothic'";
  ctx.fillText("イボジッチ", 40, 30);
  ctx.fillText("キレジッチ", canvas.width - 220, 30);
}

function drawGameOver() {
  drawGame();

  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "#fff";
  ctx.font = "bold 40px 'Yu Gothic'";
  const tw = ctx.measureText(resultText).width;
  ctx.fillText(resultText, (canvas.width - tw)/2, 200);

  ctx.font = "22px 'Yu Gothic'";
  const msg = "Enterキーでタイトルにもどる";
  const tw2 = ctx.measureText(msg).width;
  ctx.fillText(msg, (canvas.width - tw2)/2, 240);
}

function drawStageClear() {
  drawGame();

  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "#fff";
  ctx.font = "bold 34px 'Yu Gothic'";
  const tw = ctx.measureText("STAGE " + stage + " CLEAR").width;
  ctx.fillText("STAGE " + stage + " CLEAR", (canvas.width - tw)/2, 180);

  ctx.font = "22px 'Yu Gothic'";
  ctx.fillText(stageClearText, canvas.width/2 - 220, 220);

  const msg = "Enterキーで次のステージへ";
  const tw2 = ctx.measureText(msg).width;
  ctx.fillText(msg, (canvas.width - tw2)/2, 270);
}

// ===== メインループ =====
function loop(timestamp) {
  const dt = timestamp - lastTime;
  lastTime = timestamp;

  if (state === STATE_TITLE) {
    drawTitle();
  } else if (state === STATE_PLAYING) {
    update(dt);
    drawGame();
  } else if (state === STATE_GAMEOVER) {
    drawGameOver();
  } else if (state === STATE_STAGE_CLEAR) {
    drawStageClear();
  }

  requestAnimationFrame(loop);
}

function startGame() {
  resetGame();
  requestAnimationFrame(loop);
}
</script>
</body>
</html>
